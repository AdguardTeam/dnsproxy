package proxy

import (
	"log/slog"
	"net"
	"sync"
	"sync/atomic"
	"time"

	"github.com/miekg/dns"
)

// PrefetchQueueManager manages the prefetch queue and background refresh process
type PrefetchQueueManager struct {
	queue        *PriorityQueue
	refreshing   map[string]bool
	scheduled    map[string]*PrefetchItem // Tracks items currently in the queue, mapping key to item pointer
	refreshingMu sync.RWMutex

	tracker *hitTracker

	batchSize       int
	checkInterval   time.Duration
	refreshBefore   time.Duration
	threshold       int
	thresholdWindow time.Duration
	semaphore       chan struct{}
	wakeCh          chan struct{}

		needRefresh = append(needRefresh, item)
	}

	if len(needRefresh) == 0 {
		return
	}

	var wg sync.WaitGroup
	for _, item := range needRefresh {
		wg.Add(1)
		go func(item *PrefetchItem) {
			defer wg.Done()

			// Acquire semaphore
			pm.semaphore <- struct{}{}
			defer func() { <-pm.semaphore }()

			pm.refreshItem(item)
			ReleasePrefetchItem(item)
		}(item)
	}

	wg.Wait()
}

func (pm *PrefetchQueueManager) refreshItem(item *PrefetchItem) {
	key := pm.makeKey(item.Domain, item.QType, item.Subnet)

	pm.refreshingMu.Lock()
	if pm.refreshing[key] {
		pm.refreshingMu.Unlock()
		return
	}
	pm.refreshing[key] = true
	// Clear scheduled so it can be added again if needed
	delete(pm.scheduled, key)
	pm.refreshingMu.Unlock()

	defer func() {
		pm.refreshingMu.Lock()
		delete(pm.refreshing, key)
		pm.refreshingMu.Unlock()
	}()

	req := &dns.Msg{}
	req.SetQuestion(item.Domain, item.QType)
	req.RecursionDesired = true

	// Add ECS if present
	if item.Subnet != nil {
		o := new(dns.OPT)
		o.Hdr.Name = "."
		o.Hdr.Rrtype = dns.TypeOPT
		e := new(dns.EDNS0_SUBNET)
		e.Code = dns.EDNS0SUBNET
		e.Family = 1 // IPv4
		if item.Subnet.IP.To4() == nil {
			e.Family = 2 // IPv6
		}
		ones, _ := item.Subnet.Mask.Size()
		e.SourceNetmask = uint8(ones)
		e.SourceScope = 0
		e.Address = item.Subnet.IP
		o.Option = append(o.Option, e)
		req.Extra = append(req.Extra, o)
	}
	k := domain + ":" + dns.TypeToString[qtype]
	if subnet != nil {
		k += ":" + subnet.String()
	}
	return k
}

// CheckThreshold checks if the domain has reached the access threshold
func (pm *PrefetchQueueManager) CheckThreshold(domain string, qtype uint16, subnet *net.IPNet) bool {
	key := pm.makeKey(domain, qtype, subnet)
	return pm.tracker.record(key, pm.threshold, pm.thresholdWindow)
}

type hitTracker struct {
	hits       map[string]int
	lastAccess map[string]time.Time
	mu         sync.Mutex
}

func newHitTracker() *hitTracker {
	return &hitTracker{
		hits:       make(map[string]int),
		lastAccess: make(map[string]time.Time),
	}
}

func (ht *hitTracker) record(key string, threshold int, window time.Duration) bool {
	ht.mu.Lock()
	defer ht.mu.Unlock()

	if threshold <= 1 {
		return true
	}

	now := time.Now()
	if window > 0 {
		if last, ok := ht.lastAccess[key]; ok {
			if now.Sub(last) > window {
				ht.hits[key] = 0
			}
		}
		ht.lastAccess[key] = now
	}

	ht.hits[key]++
	return ht.hits[key] >= threshold
}

func (ht *hitTracker) cleanup(window time.Duration) {
	ht.mu.Lock()
	defer ht.mu.Unlock()

	now := time.Now()
	expiry := window * 2
	if expiry == 0 {
		expiry = 1 * time.Hour
	}

	for k, t := range ht.lastAccess {
		if now.Sub(t) > expiry {
			delete(ht.lastAccess, k)
			delete(ht.hits, k)
		}
	}
}

// PrefetchStats contains statistics about the prefetch manager.
type PrefetchStats struct {
	Enabled         bool   `json:"enabled"`
	QueueLen        int    `json:"queue_len"`
	ScheduledCount  int    `json:"scheduled_count"`
	UniqueDomains   int    `json:"unique_domains"`
	TotalProcessed  int64  `json:"total_processed"`
	TotalRefreshed  int64  `json:"total_refreshed"`
	TotalFailed     int64  `json:"total_failed"`
	LastRefreshTime string `json:"last_refresh_time"`
	BatchSize       int    `json:"batch_size"`
	MaxConcurrent   int    `json:"max_concurrent"`
	Threshold       int    `json:"threshold"`
}

// Stats returns the current statistics of the prefetch manager.
func (pm *PrefetchQueueManager) Stats() *PrefetchStats {
	pm.refreshingMu.Lock()
	scheduledCount := len(pm.scheduled)
	uniqueDomains := pm.countUniqueDomains()
	pm.refreshingMu.Unlock()

	// Format last refresh time
	lastRefresh := "never"
	if ts := pm.lastRefreshTime.Load(); ts > 0 {
		lastRefresh = time.Unix(ts, 0).Format(time.RFC3339)
	}

	return &PrefetchStats{
		Enabled:         true,
		QueueLen:        pm.queue.Len(),
		ScheduledCount:  scheduledCount,
		UniqueDomains:   uniqueDomains,
		TotalProcessed:  pm.totalProcessed.Load(),
		TotalRefreshed:  pm.totalRefreshed.Load(),
		TotalFailed:     pm.totalFailed.Load(),
		LastRefreshTime: lastRefresh,
		BatchSize:       pm.batchSize,
		MaxConcurrent:   cap(pm.semaphore),
		Threshold:       pm.threshold,
	}
}

// countUniqueDomains counts the number of unique domains in the scheduled map
// Must be called with refreshingMu held
func (pm *PrefetchQueueManager) countUniqueDomains() int {
	domains := make(map[string]struct{})
	for _, item := range pm.scheduled {
		domains[item.Domain] = struct{}{}
	}
	return len(domains)
}
